#!/usr/bin/perl -w

(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;
use Function::Parameters qw(:strict);

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../perllib";
use lib "$mydir/../ftemplate/lib";
use lib "$mydir/../lib";

our $outbase= "$mydir/out";

mkdir $outbase;

use Text::Markdown 'markdown';
use Chj::IO::Command;
use Chj::xperlfunc ':all';
use Chj::xopen ":all";

our $c= Chj::IO::Command->new_sender("git","ls-files","-z");
our $files= [grep {
    /\.md$/
} $c->xreadline0chop];
$c->xxfinish;


fun author_date ($path) {
    my $c= Chj::IO::Command->new_sender
      ("git", "log", '--pretty=format:%aD', "--", $path);
    my $res= $c->xreadline;
    $c->xfinish;
    chomp $res; $res;
}

fun path0 ($path) {
    ## ugly way to strip path prefix
    my $path0= $path;
    while ($path0=~ s|^\.\./||){}; die if $path0=~ /\.\./;
    $path0
}

fun is_allcaps ($str) {
    not $str=~ /[a-z]/
}

fun if_suffix_md2html ($path0,$then,$otherwise) {
    if ($path0 eq "README.md") {
	@_=("index.xhtml"); goto $then;
    } else {
	if ($path0=~ s/(.*?)([^\/]*)\.md$/$1$2.xhtml/) {
	    @_=(is_allcaps ($2) ? $1.lc($2).".xhtml" : $path0); goto $then;
	} else {
	    @_=($path0); goto $otherwise
	}
    }
}

use Chj::TEST ":all";
fun TEST_if_suffix_md2html ($in,$thenotherwise,$out) {
    TEST{if_suffix_md2html $in, sub {["then",@_]}, sub{["otherwise",@_]}}
      [$thenotherwise,$out];
}
TEST_if_suffix_md2html "README.md",'then','index.xhtml';
TEST_if_suffix_md2html "Foo/index.md",'then','Foo/index.xhtml';
TEST_if_suffix_md2html "Foo/README.md",'then','Foo/readme.xhtml';
TEST_if_suffix_md2html "Foo/READMe.md",'then','Foo/READMe.xhtml';
TEST_if_suffix_md2html "Foo/MY.css",'otherwise','Foo/MY.css';


fun url_md2html ($url) {
    my $u= URI->new($url);
    my $path= $u->path;
    if_suffix_md2html
      ($path,
       fun ($path) {
	   $u->path($path);
       },
       fun ($path) {
       });
    "$u"
}

fun xsuffix_md2html ($path0) {
    if_suffix_md2html($path0,sub{$_[0]},sub{die})
}

fun path02outpath ($path0) {
    "$outbase/".xsuffix_md2html($path0)
}

fun getfile ($path) {
    my $in= xopen_read ($path);
    binmode $in, ":utf8" or die;
    $in->xcontent
}

fun putfile ($path,$str) {
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    $out->xprint($str);
    $out->xclose;
}

use HTML::TreeBuilder;
fun htmlparse_raw ($htmlstr,$whichtag) {
    my $t= HTML::TreeBuilder->new;
    $t->parse_content ($htmlstr);
    my $e= $t->elementify;
    # (^ actually mutates $t into the HTML::Element object already, ugh)
    $e->find_by_tag_name($whichtag)
}

use URI;
fun url_is_internal ($str) {
    my $u= URI->new($str);
    not defined $u->scheme
}

use Chj::PXML;
fun htmlmap ($e) {
    my $name= lc($e->tag);
    my $atts=();
    for ($e->all_external_attr_names) {
	next if $_ eq "/";
	die "att name '$_'" unless /^\w+\z/s;
	$$atts{lc $_}= $e->attr($_);
    }
    # fix internal .md links
    if ($name eq "a"
	and url_is_internal($$atts{href})) {
	$$atts{href}= url_md2html ($$atts{href});
    }
    my $res= Chj::PXML->new
	($name,
	 $atts,
	 [
	  map {
	      if (ref $_) {
		  # another HTML::Element
		  no warnings "recursion";# XX should rather sanitize input?
		  htmlmap ($_)
	      } else {
		  # a string
		  $_
	      }
	  } @{$e->content||[]}
	 ]);
    # add anchors
    if ($name =~ /^h(\d)$/) {
	my $bodystr= join("", @{$res->body}); ## should add method, also ~handle subelts
	$bodystr=~ s/ /_/sg;
	[
	 A({name=> $bodystr}),
	 $res
	]
    } else {
	$res
    }
}

fun htmlparse ($str,$whichtag) {
    htmlmap htmlparse_raw ($str,$whichtag)
}

use Chj::PXML::Serialize 'pxml_xhtml_print_fast';

fun puthtmlfile ($path,$p) {
    xmkdir_p dirname $path;
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    pxml_xhtml_print_fast($p, $out, "en");# hard coded lang
    $out->xclose;
}

use Chj::PXHTML ":all";
use Chj::FP::ArrayUtil ":all";
use File::Spec;
use Chj::FP::Array_sort;


our $sortorder=
  [qw(
	 README.md
	 INSTALL.md
	 docs/usage.md
	 docs/phases.md
	 docs/message_identification.md
	 docs/warnings.md
	 TODO.md
	 docs/hacking.md
	 docs/mbox.md
	 COPYING.md
    )];

our $path02sortkey= do {
    my $sortprio= do {
	my $i=1;
	+{map { $_=> sprintf('-%04d', $i++) } @$sortorder}
    };
    fun ($path0) {
	$$sortprio{$path0} || $path0
    }
};

my $usagehook= 'Run `./ml2json --help`.';
use Chj::xpipe;
sub helptext {
    my ($path,$path0)=@_;
    ## (ugly again)
    my $diff= substr ($path, 0, length ($path) - length( $path0));
    my ($r,$w)= xpipe;
    if (xfork) {
	$w->xclose;
	my $str=$r->xcontent;
	xwait;
	warn "error in subprocess, $?" unless $? == 0;
	$str
    } else {
	#$r->xclose;
	local $ENV{ML2JSON_MYDIR}=".";
	open STDOUT, ">&".fileno($w) or die $!;
	open STDERR, ">&".fileno($w) or die $!;
	xchdir $diff if length $diff;
	xexec "./ml2json","--help";
    }
}

fun path02title ($path0) {
    my $str= basename( xsuffix_md2html ($path0),".xhtml");
    $str=~ s/_/ /sg;
    ucfirst $str
}


# move to lib
use File::Spec;
use Chj::TEST ":all";

fun url_diff ($path0from,$path0to) {
    my $from= $path0from=~ m|(.*?)/+$|s ? $1 : dirname $path0from;
    File::Spec->abs2rel($path0to, $from);
}

TEST{url_diff "foo/", "bar.css"} '../bar.css';
TEST{url_diff "foo/bar.html", "bar.css"} '../bar.css';
TEST{url_diff "foo", "bar.css"} 'bar.css';
#TEST{url_diff ".", "bar.css"} 'bar.css';

#/lib

use Chj::FP2::Lazy ":all";
use Chj::FP2::List ":all";
use Chj::FP2::Stream ":all";

{
    package CHJ::Cost;
    use Chj::FP::ArrayUtil ":all";
    use Chj::Struct [qw(name is_purchaseable basecosts val)];
    method cost ($index) {
	$$self{_cost} ||= do {
	    add($self->val,
		map {
		    $$index{$_}->cost ($index)
		} @{$self->basecosts}
	       );
	}
    }
    _END_
}
{
    package CHJ::Totalcost;
    use Chj::FP::Array_sort ":all";
    use Chj::Struct [qw(costs)];
    method range () {
	@{$$self{costs}} or die "no costs given";#
	my $index;
	for (@{$$self{costs}}) {
	    if (defined (my $name= $_->name)) {
		$$index{$name}= $_
	    }
	}
	my $purchaseable= [grep { $_->is_purchaseable } @{$$self{costs}}];
	@$purchaseable or die "no purchaseable costs";#
	local our $all= array_sort
	  ( $purchaseable,
	    on the_method ("cost",$index), \&number_cmp );
	(@$all == 1
	 ? $$all[0]->cost ($index)
	 : $$all[0]->cost ($index)."..".$$all[-1]->cost($index)),
    }
    _END_
}


fun genfile ($path) {
    my $path0= path0 $path;
    my $outpath= path02outpath($path0);
    mkdir dirname( $outpath);

    my $filetitle= path02title $path0;

    my $str= getfile $path;

    $str=~ s/^\(Check the.*?website.*?---\s+//s
      or $path=~/COPYING|bugs\// or warn "'$path' is missing hint";

    if ($path0 eq "docs/usage.md") {
	$str=~ s{\Q$usagehook}{
	    my $str= helptext($path,$path0);
	    $str=~ s/^/    /mg;
	    "Skip to [instructions](#Instructions) below to see a recipe.\n\n".
	    "    \$ ./ml2json --help\n".
	      $str
	}e or warn "no match"
    }

    my $maybe_costrange= do {
	# extract Cost indicators:
	my $namere= qr/\w+/;
	my $nameplusre= qr/\(?$namere\)?/;
	my $perhaps_nameplus2name= fun ($maybe_nameplus) {
	    if (defined $maybe_nameplus) {
		my ($name)= $maybe_nameplus=~ qr/($namere)/
		  or die "bug";
		$name
	    } else {
		undef
	    }
	};
	local our $costs=[];
	while (#my ($name,$basecosts,$val)=
	       $str=~ m{\b[Cc]ost
			# name: parentheses for "library cost"
			(?:\s+($nameplusre))?
			:
			\s*
			# base costs
			((?:$nameplusre\s*\+\s*)*)
			\s*
			# amount
			\$\s*(\d+)
		   }gx) {
	    my ($nameplus,$basecosts,$val)=($1,$2,$3);# perl.
	    my $name= &$perhaps_nameplus2name($nameplus);
	    my @basecosts= map { &$perhaps_nameplus2name($_) }
	      split /\s*\+\s*/, $basecosts;
	    push @$costs, new CHJ::Cost ($name,
					 (not $nameplus
					  or not($nameplus=~ /^\(/)),
					 \@basecosts,
					 $val);
	}
	#local our $totalcost=
	#  CHJ::Totalcost->new($costs);
	#use Chj::Backtrace; use Chj::repl;repl if @$costs;#exit;
	@$costs ? CHJ::Totalcost->new($costs)->range : undef
    };

    my $body= htmlparse(markdown ($str), "body");

    my ($h1,$body1)= do {
	my $body= $body->body;
	my $b= stream_mixed_flatten(do{my $body=$body;$body});
	my $bwithoutanchor= Force stream_drop_while
	  (
	   fun ($v) {
	       (ref $v
		and $v->name eq "a"
		and $v->maybe_attribute("name"))
	   },
	   $b);
	my $b0= car $bwithoutanchor;
	if (ref $b0 and $b0->name eq "h1") {
	    ($b0, stream2array(cdr $bwithoutanchor))
	} else {
	    (H1(path02title ($path0)), $body)
	}
    };

    puthtmlfile($outpath,
		HTML (
		      HEAD (
			    TITLE ($filetitle, " - ml2json"),
			    LINK ({rel=> "stylesheet",
				   href=> url_diff ($path0, "my.css"),
				   type=> "text/css"}),
			   ),
		      BODY(
			   DIV ({class=>"header"},
				SPAN({class=>"logo"}, "ml2json"),
				" mail archive processor"),
			   UL({class=> "menu"},
			      array_map_with_i
			      (
			       fun ($i,$file0) {
				   my $filetitle= path02title $file0;
				   my $is_last= ($i == $#$files);
				   LI({class=> ($is_last ? "menu_last" : "menu")},
				      ($file0 eq $path0 ?
				       SPAN({class=> "menu_selected"},
					    $filetitle)
				       : A ({class=> "menu",
					     href=>
					     File::Spec->abs2rel
					     (xsuffix_md2html($file0),
					      dirname($path0))},
					    $filetitle)),
				      " ")
			       },
			       array_sort
			       (array_map( \&path0, $files),
				on $path02sortkey, \&string_cmp))),
			   $h1,
			   $body1,
			   BR,
			   HR,
			   $maybe_costrange ? P('Cost range: $',
						$maybe_costrange) : (),
			   DIV({class=>"footer_date"}, author_date($path)))));
}

genfile $_ for @$files;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
