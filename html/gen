#!/usr/bin/perl -w

(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;
use Function::Parameters qw(:strict);

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/../perllib";
use lib "$mydir/../ftemplate/lib";
use lib "$mydir/../lib";

our $outbase= "$mydir/out";

mkdir $outbase;

use Text::Markdown 'markdown';
use Chj::IO::Command;
use Chj::xperlfunc ':all';
use Chj::xopen ":all";

our $c= Chj::IO::Command->new_sender("git","ls-files","-z");
our $files= [grep {
    /\.md$/
} $c->xreadline0chop];
$c->xxfinish;


fun author_date ($path) {
    my $c= Chj::IO::Command->new_sender
      ("git", "log", '--pretty=format:%aD', "--", $path);
    my $res= $c->xreadline;
    $c->xfinish;
    chomp $res; $res;
}

fun path0 ($path) {
    ## ugly way to strip path prefix
    my $path0= $path;
    while ($path0=~ s|^\.\./||){}; die if $path0=~ /\.\./;
    $path0
}

fun suffix_md2html ($path0) {
    if ($path0 eq "README.md") {
	"index.html"
    } else {
	$path0=~ s/\.md$/.xhtml/ or die;
	lc $path0
    }
}

fun url_md2html ($url) {
    my $u= URI->new($url);
    my $path= $u->path;
    if ($path eq "README.md") { # XX should check basename, actually
	$u->path("index.html");
    } else {
	if ($path=~ s/\.md$/.xhtml/) {
	    $u->path(lc $path);
	}
    }
    "$u"
}

fun path02html ($path0) {
    "$outbase/".suffix_md2html($path0)
}

fun getfile ($path) {
    my $in= xopen_read ($path);
    binmode $in, ":utf8" or die;
    $in->xcontent
}

fun putfile ($path,$str) {
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    $out->xprint($str);
    $out->xclose;
}

use HTML::TreeBuilder;
fun htmlparse_raw ($htmlstr,$whichtag) {
    my $t= HTML::TreeBuilder->new;
    $t->parse_content ($htmlstr);
    my $e= $t->elementify;
    # (^ actually mutates $t into the HTML::Element object already, ugh)
    $e->find_by_tag_name($whichtag)
}

use URI;
fun url_is_internal ($str) {
    my $u= URI->new($str);
    not defined $u->scheme
}

use Chj::PXML;
fun htmlmap ($e) {
    my $name= lc($e->tag);
    my $atts=();
    for ($e->all_external_attr_names) {
	next if $_ eq "/";
	die "att name '$_'" unless /^\w+\z/s;
	$$atts{lc $_}= $e->attr($_);
    }
    # fix internal .md links
    if ($name eq "a"
	and url_is_internal($$atts{href})) {
	$$atts{href}= url_md2html ($$atts{href});
    }
    my $res= Chj::PXML->new
	($name,
	 $atts,
	 [
	  map {
	      if (ref $_) {
		  # another HTML::Element
		  no warnings "recursion";# XX should rather sanitize input?
		  htmlmap ($_)
	      } else {
		  # a string
		  $_
	      }
	  } @{$e->content||[]}
	 ]);
    # add anchors
    if ($name =~ /^h(\d)$/) {
	my $bodystr= join("", @{$res->body}); ## should add method, also ~handle subelts
	$bodystr=~ s/ /_/sg;
	[
	 A({name=> $bodystr}),
	 $res
	]
    } else {
	$res
    }
}

fun htmlparse ($str,$whichtag) {
    htmlmap htmlparse_raw ($str,$whichtag)
}

use Chj::PXML::Serialize 'pxml_xhtml_print_fast';

fun puthtmlfile ($path,$p) {
    my $out= xopen_write($path);
    binmode $out, ":utf8" or die;
    pxml_xhtml_print_fast($p, $out, "en");# hard coded lang
    $out->xclose;
}

use Chj::PXHTML ":all";
use Chj::FP::ArrayUtil ":all";
use File::Spec;
use Chj::FP::Array_sort;


our $sortorder=
  [qw(
	 README.md
	 INSTALL.md
	 docs/usage.md
	 docs/phases.md
	 docs/message_identification.md
	 docs/warnings.md
	 TODO.md
	 docs/hacking.md
	 docs/mbox.md
	 COPYING.md
    )];

our $path02sortkey= do {
    my $sortprio= do {
	my $i=1;
	+{map { $_=> sprintf('-%04d', $i++) } @$sortorder}
    };
    fun ($path0) {
	$$sortprio{$path0} || $path0
    }
};

my $usagehook= 'Run `./ml2json --help`.';
use Chj::xpipe;
sub helptext {
    my ($path,$path0)=@_;
    ## (ugly again)
    my $diff= substr ($path, 0, length ($path) - length( $path0));
    my ($r,$w)= xpipe;
    if (xfork) {
	$w->xclose;
	my $str=$r->xcontent;
	xwait;
	warn "error in subprocess, $?" unless $? == 0;
	$str
    } else {
	#$r->xclose;
	local $ENV{ML2JSON_MYDIR}=".";
	open STDOUT, ">&".fileno($w) or die $!;
	open STDERR, ">&".fileno($w) or die $!;
	xchdir $diff if length $diff;
	xexec "./ml2json","--help";
    }
}

fun path02title ($path0) {
    my $str= lc( basename $path0,".md" );
    $str=~ s/_/ /sg;
    ucfirst $str
}


# move to lib
use File::Spec;
use Chj::TEST ":all";

fun url_diff ($path0from,$path0to) {
    my $from= $path0from=~ m|(.*?)/+$|s ? $1 : dirname $path0from;
    File::Spec->abs2rel($path0to, $from);
}

TEST{url_diff "foo/", "bar.css"} '../bar.css';
TEST{url_diff "foo/bar.html", "bar.css"} '../bar.css';
TEST{url_diff "foo", "bar.css"} 'bar.css';
#TEST{url_diff ".", "bar.css"} 'bar.css';

#/lib

use Chj::FP2::Lazy ":all";
use Chj::FP2::List ":all";
use Chj::FP2::Stream ":all";

fun genfile ($path) {
    my $path0= path0 $path;
    my $outpath= path02html($path0);
    mkdir dirname( $outpath);

    my $filetitle= path02title $path0;

    my $str= getfile $path;

    $str=~ s/^\(Check the.*?website.*?---\s+//s
      or $path=~/COPYING/ or warn "'$path' is missing hint";

    if ($path0 eq "docs/usage.md") {
	$str=~ s{\Q$usagehook}{
	    my $str= helptext($path,$path0);
	    $str=~ s/^/    /mg;
	    "Skip to [instructions](#Instructions) below to see a recipe.\n\n".
	    "    \$ ./ml2json --help\n".
	      $str
	}e or warn "no match"
    }

    my $body= htmlparse(markdown ($str), "body");

    my ($h1,$body1)= do {
	my $body= $body->body;
	my $b= stream_mixed_flatten(do{my $body=$body;$body});
	my $bwithoutanchor= Force stream_drop_while
	  (
	   fun ($v) {
	       (ref $v
		and $v->name eq "a"
		and $v->maybe_attribute("name"))
	   },
	   $b);
	my $b0= car $bwithoutanchor;
	if (ref $b0 and $b0->name eq "h1") {
	    ($b0, stream2array(cdr $bwithoutanchor))
	} else {
	    (H1(path02title ($path0)), $body)
	}
    };

    puthtmlfile($outpath,
		HTML (
		      HEAD (
			    TITLE ($filetitle, " - ml2json"),
			    LINK ({rel=> "stylesheet",
				   href=> url_diff ($path0, "my.css"),
				   type=> "text/css"}),
			   ),
		      BODY(
			   DIV ({class=>"header"},
				SPAN({class=>"logo"}, "ml2json"),
				" mail archive processor"),
			   UL({class=> "menu"},
			      array_map_with_i
			      (
			       fun ($i,$file0) {
				   my $filetitle= path02title $file0;
				   my $is_last= ($i == $#$files);
				   LI({class=> ($is_last ? "menu_last" : "menu")},
				      ($file0 eq $path0 ?
				       SPAN({class=> "menu_selected"},
					    $filetitle)
				       : A ({class=> "menu",
					     href=>
					     File::Spec->abs2rel
					     (suffix_md2html($file0),
					      dirname($path0))},
					    $filetitle)),
				      " ")
			       },
			       array_sort
			       (array_map( \&path0, $files),
				on $path02sortkey, \&string_cmp))),
			   $h1,
			   $body1,
			   BR,
			   HR,
			   DIV({class=>"footer_date"}, author_date($path)))));
}

genfile $_ for @$files;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
