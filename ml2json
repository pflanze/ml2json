#!/usr/bin/perl -w

# Thu Jul  4 21:30:42 BST 2013
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/perllib";
use lib "$mydir/ftemplate/lib";
use lib "$mydir/lib";

our $tmpbase="/tmp/$myname";
our $tmplink= "$ENV{HOME}/.$myname-tmp"; ## ok to use that path?

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname sourcedir targetfile

  sourcedir should be a directory with *.mbox files directly in it
  ($myname does not currently recurse into subdirectories).

  targetfile is where the JSON output should go (use '-' for stdout).

  Options:

    --cleanup   delete currently used temp directory at $tmpbase*

    --attachment-basedir path
                use path instead of a random subdirectory below
                '$tmpbase' for the output; the output currently
                contains serialized objects as well, but those don't
                hurt, do they?
                If path is absolute, then the url field for
                attachments is output as file:// URI, if it is
                relative, it is output as a relative URI (i.e. no
                file:// prefix).

    --config myconfig.pl
                load given file containing perl code, which must
                end with a perl hashref; currently
                   'jsonfields_orig_headers' and 'jsonfields_top'
                are used. See docs in lib/Chj/Ml2json/OutputJSON.pm

    --deidentify string
                print message identified by the given string, which is
                output into the JSON by the json_identify method (as
                'identify' field by default) or printed along with
                WARN and ERROR messages.
                Only works if the generated files are still available.
                If --attachment-basedir was given before, it has to
                be specified for --deidentify as well.

    --show-mbox-path md5hexstring[/number]
                show path of original mbox file for a given mbox identifier
                (as they are used in identify strings).

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $config;
our $opt_deidentify;
our $opt_show_mbox_path;
our $opt_attachment_basedir;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "cleanup"=> sub { cleanup_tmp(); exit 0; },
	   "attachment-basedir=s"=> \$opt_attachment_basedir,
	   "config=s"=> sub {
	       my ($_,$path)=@_;
	       $config= require $path
	   },
	   "deidentify=s"=> \$opt_deidentify,
	   "show-mbox-path=s"=> \$opt_show_mbox_path,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==2 or $opt_deidentify or $opt_show_mbox_path;

use Chj::tempdir;

use Chj::xperlfunc ':all';

our $tmp= $opt_attachment_basedir || do {
    my $create= sub {
	my $t= tempdir $tmpbase;
	xsymlink $t, $tmplink;
	$t
    };
    if (my $p= readlink( $tmplink)) {
	if (my $s= Xstat $p) {
	    if ($s->uid == $>) {
		$p
	    } else {
		warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else, creating a new one instead";
		xunlink $tmplink;
		&$create;
	    }
	} else {
	    xunlink $tmplink;
	    &$create;
	}
    } else {
	&$create;
    }
};


sub print_deidentify {
    my ($str)=@_;
    my $m= Chj::Ml2json::Debug::deidentify($str,$tmp);
    print $m->ent->as_string
      or die $!;
}
if ($opt_deidentify) {
    require Chj::Ml2json::Debug;
    print_deidentify $opt_deidentify;
}

if ($opt_show_mbox_path) {
    my ($md5)= $opt_show_mbox_path=~ /\b([a-f0-9]{32})\b/
      or usage "does not contain an md5 hex string: '$opt_show_mbox_path'";
    my $p="$tmp/$md5";
    my $mbox= Chj::Ml2json::Ghostable->load($p);
    if (my $path= $mbox->path) {
	print $path or die $!;
    } else {
	die "The object stored at '$p' does not have path field, seems to have been generated before adding this feature; run --cleanup and run the conversion again";
    }
}

sub cleanup_tmp {
    if ($opt_attachment_basedir) {
	my $p= $opt_attachment_basedir;
	system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
    } else {
	# partially COPYPASTE..
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p=~ m|^/| or die "not an absolute target location: '$p'";
		    unlink $tmplink;
		    system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else";
		}
	    } else {
		xunlink $tmplink;
	    }
	}
    }
}

use Chj::Ml2json::Mailcollection ':all';
use Chj::FP2::Stream ':all';
use Chj::Ml2json::OutputJSON;
use Chj::Ml2json::OutputJSON::Continuous;
use Chj::Ml2json::Try;
use Chj::xopen ':all';

sub parse_and_convert {
    my ($sourcedir, $targetfile)=@ARGV;

    #my $coll= parse_mbox ('mbox/foucault-l.mbox.crdownload.1', $tmp);
    my $coll= parse_mbox_dir ($sourcedir, $tmp);

    my $index= $coll->index;

    my $outputjson= Chj::Ml2json::OutputJSON->new
      ($$config{jsonfields_orig_headers},
       $$config{jsonfields_top});

    my $allout= sub {
	my $o= xopen_write $targetfile;
	binmode $o, ":utf8" or die;
	my $json= Chj::Ml2json::OutputJSON::Continuous->new($o,$outputjson);
	stream_for_each sub {
	    my ($m)=@_;
	    Try {
		$json->message_print($m,$index);
	    } $m;
	}, $index->messages_threadsorted;
	$json->end;
	$o->xclose;
    };

    &$allout;
}


#use Chj::Ml2json::Debug;
#use Chj::Ml2json::MIMEExtract ':all';
use Chj::Backtrace;
#use Chj::repl; repl;

parse_and_convert if @ARGV;
