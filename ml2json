#!/usr/bin/perl -w

# Thu Jul  4 21:30:42 BST 2013
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/perllib";
use lib "$mydir/ftemplate/lib";
use lib "$mydir/lib";

our $tmpbase="/tmp/$myname";
our $tmplink= "$ENV{HOME}/.$myname-tmp"; ## ok to use that path?
our $mbox_glob= '*.mbox';

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname sourcedir-or-file(s) [--json-to targetfile]

  sourcedir should be a directory with *.mbox files directly in it
  ($myname does not currently recurse into subdirectories).
  If a file is given instead, it is assumed to be an mbox file.

  Options:
    --verbose   show NOTEs in addition to WARNings on stderr

    --recurse   recurse into subdirectories of sourcedir-or-file

    --mbox-glob globstring
                glob to use to find files in directories that contain
                mboxes. Defaults to '$mbox_glob'.

    --cleanup   delete currently used temp directory at $tmpbase*

    --attachment-basedir path
                use path instead of a random subdirectory below
                '$tmpbase' for the output; the output currently
                contains serialized objects as well, but those don't
                hurt, do they?
                If path is absolute, then the url field for
                attachments is output as file:// URI, if it is
                relative, it is output as a relative URI (i.e. no
                file:// prefix).

    --config myconfig.pl
                load given file containing perl code, which must
                end with a perl hashref; currently
                   'jsonfields_orig_headers' and 'jsonfields_top'
                are used. See docs in lib/Chj/Ml2json/OutputJSON.pm


    --max-date-deviation seconds
                When mbox separators (lines starting with 'From ')
                contain time stamps, and those deviate more than
                <seconds> from the Date header contained in the mail
                (of if there is no Date header in the mail), use the
                mbox time stamp instead. Default: off.  Note: mbox
                time stamps are not necessarily representing the time
                when an email was received, could also be when they
                were copied around.

    --json-to file
                where the JSON output should go (use '-' for stdout).

    --html-to dir
                create html files in the specified directory
                (currently meant for debugging only)

    --source-to dir
                create files <dir>/<md5hash>/<number>.txt (where
                <md5hash>/<number> is the same string that
                --deidentify takes) and link them in the html files
                produced with --html-to

    --deidentify string
                print message identified by the given string, which is
                output into the JSON by the json_identify method (as
                'identify' field by default) or printed along with
                WARN and ERROR messages.
                Only works if the generated files are still available.
                If --attachment-basedir was given before, it has to
                be specified for --deidentify as well.

    --show-mbox-path md5hexstring[/number]
                show path of original mbox file for a given mbox
                identifier (as they are used in identify strings).

  (Option names can be shortened as long as they are unambiguous and
  that you take the risk for future ambiguity.)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $config;
our $opt_deidentify;
our $opt_show_mbox_path;
our $opt_attachment_basedir;
our $opt_max_date_deviation;
our $opt_recurse;
our $opt_repl;
our $opt_json_to;
our $opt_html_to;
our $opt_source_to;
GetOptions("verbose"=> \$verbose,
	   "repl"=> \$opt_repl,
	   "help"=> sub{usage},
	   "cleanup"=> sub { cleanup_tmp(); exit 0; },
	   "attachment-basedir=s"=> \$opt_attachment_basedir,
	   "mbox-glob=s"=> \$mbox_glob,
	   "recurse"=> \$opt_recurse,
	   "config=s"=> sub {
	       my ($_,$path)=@_;
	       $config= require $path
	   },
	   "max-date-deviation=n"=> \$opt_max_date_deviation,
	   "json-to=s"=> \$opt_json_to,
	   "html-to=s"=> \$opt_html_to,
	   "source-to=s"=> \$opt_source_to,
	   "deidentify=s"=> \$opt_deidentify,
	   "show-mbox-path=s"=> \$opt_show_mbox_path,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless
  (@ARGV and ($opt_json_to or $opt_html_to or $opt_source_to))
  or $opt_deidentify or $opt_show_mbox_path or $opt_repl;

use Chj::NoteWarn;
NoteWarn_attenuation_level($verbose ? 0 : 1);

use Chj::tempdir;

use Chj::xperlfunc ':all';

our $tmp= do {
    if ($opt_attachment_basedir) {
	xmkdir $opt_attachment_basedir if not -d $opt_attachment_basedir;
	$opt_attachment_basedir
    } else {
	my $create= sub {
	    my $t= tempdir $tmpbase;
	    xsymlink $t, $tmplink;
	    $t
	};
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else, creating a new one instead";
		    xunlink $tmplink;
		    &$create;
		}
	    } else {
		xunlink $tmplink;
		&$create;
	    }
	} else {
	    &$create;
	}
    }
};


sub print_deidentify {
    my ($str)=@_;
    my $m= Chj::Ml2json::Debug::deidentify($str,$tmp);
    print $m->ent->as_string
      or die $!;
}
if ($opt_deidentify) {
    require Chj::Ml2json::Debug;
    print_deidentify $opt_deidentify;
}

if ($opt_show_mbox_path) {
    my ($md5)= $opt_show_mbox_path=~ /\b([a-f0-9]{32})\b/
      or usage "does not contain an md5 hex string: '$opt_show_mbox_path'";
    my $p="$tmp/$md5";
    my $mbox= Chj::Ml2json::Ghostable->load($p);
    if (my $path= $mbox->path) {
	print $path,"\n" or die $!;
    } else {
	die "The object stored at '$p' does not have path field, seems to have been generated before adding this feature; run --cleanup and run the conversion again";
    }
}

sub cleanup_tmp {
    if ($opt_attachment_basedir) {
	my $p= $opt_attachment_basedir;
	system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
    } else {
	# partially COPYPASTE..
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p=~ m|^/| or die "not an absolute target location: '$p'";
		    unlink $tmplink;
		    system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else";
		}
	    } else {
		xunlink $tmplink;
	    }
	}
    }
}

use Chj::Ml2json::MailcollectionParser;
use Chj::Ml2json::Message;
use Chj::FP2::Stream ':all';
use Chj::Ml2json::OutputJSON;
use Chj::Ml2json::OutputJSON::Continuous;
use Chj::Try;
use Chj::xopen ':all';
use Chj::Ml2json::Parse::HTML;
use Chj::xperlfunc ':all';

our $collectionparser= Chj::Ml2json::MailcollectionParser->new
  ('Chj::Ml2json::Message',
   $mbox_glob,
   $opt_recurse);

our $htmlmapper= Chj::Ml2json::Parse::HTML->new; ## config file input ?

our $outputjson= Chj::Ml2json::OutputJSON->new
  ($$config{jsonfields_orig_headers},
   $$config{jsonfields_top},
   $htmlmapper);

use Chj::PXML::Serialize 'pxml_xhtml_print_fast';
use Chj::PXHTML ':all';
sub with_wrap_if (&$$){
    my ($fn,$val,$cond)=@_;
    $cond ? do{ local $_= $val; &$fn($val)} : $val
}
use Scalar::Util 'weaken';
use Chj::FP::ArrayUtil ':all';
sub nobr {
    SPAN({style=> "white-space:nowrap;"}, @_)
}
use Chj::Ml2json::Color;
our $textbackgroundcol= Chj::Ml2json::Color->new_htmlstring("#e0f0ff");
our $blockquoteendcol= Chj::Ml2json::Color->new_htmlstring("#ffffff");
sub phrase_dequote {
    my ($maybe_str)=@_;
    $maybe_str and do {
	my $str= $maybe_str;
	$str=~ s/^\s*\"//s;
 	$str=~ s/\"\s*\z//s;
	$str
    }
}

sub parse_and_convert {
    my @sourcepaths=@ARGV;

    if ($opt_html_to and not -d $opt_html_to) {
	xmkdir $opt_html_to
    }
    if ($opt_source_to and not -d $opt_source_to) {
	xmkdir $opt_source_to
    }

    my $coll= $collectionparser->parse_trees(\@sourcepaths, $tmp, $opt_max_date_deviation);

    my $index= $coll->index;

    my $allout= sub {
	my $o;
	if ($opt_json_to) {
	    $o= xopen_write $opt_json_to;
	    binmode $o, ":utf8" or die;
	}
	my $json= Chj::Ml2json::OutputJSON::Continuous->new($o,$outputjson);
	#^ XX HACK: $o may be undefined; really misusing that
	# mechanism now.
	stream_for_each sub {
	    my ($m)=@_;
	    Try {
		$json->message_print($m,$index)
		  if $opt_json_to;

		my $source_path;
		if ($opt_source_to) {
		    my $idn= $m->identify;
		    my $path= "$opt_source_to/$idn.txt";
		    mkdir dirname($path);
		    my $out= xopen_write $path;
		    # Choice of either deparsing the entity, which is
		    # not the same as what was originally parsed (but
		    # it would show what was lost in the MIME parser)
		    if (0) {
			$out->xprint($m->ent->as_string);
		    } else {
			# or re-read the slice of the original mbox
			# file; XX assumes that the file is still
			# unchanged!
			$m->mboxslice->xsendfile_to($out);
		    }
		    $out->xclose;
		    $source_path= $path;
		}
		if ($opt_html_to) {
		    my $id= $m->id;
		    my $idn= $m->identify;
		    my $p= $idn;
		    $p=~ s|/|-|g;
		    my $path= "$opt_html_to/$p.xhtml";
		    # iceweasel ignores encoding in .html files, thus
		    # needs to be .xhtml suffix
		    my $out= xopen_write $path;
		    binmode $out, ":utf8" or die;
		    my $fragment= $outputjson->html($m);
		    my $header_hashref_lc= $m->header_hashref_lc;
		    my $ctime_UTC= $outputjson->json_ctime_UTC($m,$index);
		    my $inreplyto= $outputjson->json_in_reply_to ($m,$index);
		    my $replies= $outputjson->json_replies($m,$index);
		    my $threadleaders= $outputjson->json_threadleaders($m,$index);
		    my $maybe_threadleader=
		      (@$threadleaders == 1) ? $$threadleaders[0] : undef;
		    my $id2maybe_mg= sub {
			my ($id)=@_;
			if (my $v= $index->ids->{$id}) {
			    $$v[1]
			} else {
			    ()
			}
		    };
		    my $msg_id2maybe_url= sub {
			my ($id)=@_;
			if (my $mg= &$id2maybe_mg ($id)) {
			    my $m= $mg->resurrect; # necessary as $mg->identify is different
			    my $idn= $m->identify;
			    #COPYPASTE from above
			    my $p= $idn;
			    $p=~ s|/|-|g;
			    "$p.xhtml"
			} else {
			    undef
			}
		    };
		    my @choice= $m->origplain_origrich_orightml_string;
		    my $choice= array_zip2 \@choice, [qw(plain rich html)];
		    my $choosen= $outputjson->html_choice($m);
		    #use Chj::repl;repl;


		    ###my $_id2subthread= {}; # for sharing across multiple entry points through threadleaders
		    #wohlsck

# 		    my $threadleader_simplifiedsubject= do {
# 			my $mg= &$id2maybe_mg ($_id);
# 			my $m= $mg->resurrect;
# 			my $orig_headers= $outputjson->json_orig_headers ($m,$index);
# 			subject_simplify($$orig_headers{Subject})
# 		    };

		    my $showthread; $showthread= sub {
			my ($_id)=@_;
			if (my $mg= &$id2maybe_mg ($_id)) {
			    my $m= $mg->resurrect;
			    #hm again COPYPASTE; even again to avoid fetching $m again
			    my $idn= $m->identify;
			    my $p= $idn;
			    $p=~ s|/|-|g;
			    my $url= "$p.xhtml";
			    #/CP
			    my $replies= $outputjson->json_replies($m,$index);
			    #my $orig_headers= $outputjson->json_orig_headers ($m,$index);
			    #my $subject= $$orig_headers{Subject};
			    #my $subject_is_same=
			    #  subject_simplify($subject) eq $threadleader_simplifiedsubject;
			    # need to  keep seen ones  too   or only. (if threadleader then show!)
			    #my $cnt= $subject_is_same ? 
			    my ($from)= @{$outputjson->json_parsed_from($m,undef)};
			    my $fromstr= phrase_dequote($$from{phrase}) || $$from{address};
			    my $subject= $outputjson->json_decoded_subject($m,undef);

			    my $cnt= [$subject, " ", I("(",$fromstr,")")];
			    my $possiblylinkedcnt=
			      $_id eq $id ? $cnt : A({href=> $url}, $cnt);

			    DIR(
				LI($possiblylinkedcnt),
				map {
				    &$showthread ($_)
				} @$replies
			       )
			} else {
			    # the unknown id's  hm,
			    NOTE "shouldn't happen here?: id '$_id'";##odd, actually happens
			    undef
			}
		    };
		    my $_showthread= $showthread; weaken $showthread;

		    my $perhaps_source_link= $source_path && do {
			my $rel= File::Spec->abs2rel($source_path, dirname($path));
			["; ", A({href=> $rel}, "source")]
		    };

		    my %addrs=
		      map {
			  my $vs= $outputjson->_json_mailparsed_header($m,$_);
			  ($_=> do {
			      if (@$vs) {
				  array_join
				    ([
				      map {
					  [phrase_dequote($$_{phrase}),
					   TT("<$$_{address}>"), $$_{comment}]
				      } @$vs
				     ],
				     ", ")
			      } else {
				  undef
			      }
			  })
		       } qw(from to cc);
		    my $page=
		      HTML
			(HEAD (TITLE ($idn),
			       STYLE ({type=>"text/css"},
				      map {
					  my $col= $textbackgroundcol->shade_exponentially_towards
					      ($blockquoteendcol, 0.6, $_)->htmlstring;
					  ".quotelevel_$_ { background-color:$col; }\n"
				      } 1..15)),
			 BODY
			 ({bgcolor=>"#964a2a"},
			  TABLE ({border=>0,
				  cellspacing=>3,
				  cellpadding=>16,
				  width=>"88%",
				  align=>"center",
				 },
				 TR
				 (TD
				  ({bgcolor=> "#f0f8ff"},
				   TABLE
				   ({border=>0},
				    (
				     map {
					 my ($key,$val)=@$_;
					 TR ({valign=>"top"},
					     TD ({align=>"right"},
						 "$key:$nbsp"),
					     TD ($val))
				     }
				     ["Subject",
				      #with_wrap_if {
				      #	  A({href=> &$msg_id2url ($maybe_threadleader)}, $_)
				      #} B($$orig_headers{Subject}), $maybe_threadleader
				      #sigh, more complicated (maybe monad?):
				      do {
					  my $V0= B($$header_hashref_lc{subject});
					  if ($maybe_threadleader
					      and $maybe_threadleader ne $id) {
					      if (my $V2= &$msg_id2maybe_url ($maybe_threadleader)) {
						  A({href=> $V2}, $V0)
					      } else {
						  $V0
					      }
					  } else {
					      $V0
					  }
				      }
				     ],
				     ["From", #$$header_hashref_lc{from}
				      $addrs{from}],
				     ["To",# $$header_hashref_lc{to},
				      $addrs{to},
				      #$$orig_headers{Cc}..
				      ($addrs{cc} and ", Cc: ", $addrs{cc})],
				     ["Date",
				      [$$header_hashref_lc{date}, $nbsp, " (", $ctime_UTC, " UTC)"]]
				     ),
				    TR({valign=>"top"},
				       TD(SMALL("Message-ID:")),
				       TD(SMALL($id,
						" $nbsp ",
						nobr
						("Choice:",
						 (map {
						     my ($used,$msg)=@$_;
						     ($used
						      ? [" ",
							 ($choosen eq $msg ? B($msg) : $msg)]
						      : undef)
						 } @$choice),
						 $perhaps_source_link))))))),
				 TR (TD ({bgcolor=> $textbackgroundcol->htmlstring}, $fragment)),
				 TR (TD ({bgcolor=> "#f0f8ff"},
					 ($maybe_threadleader and
					  &$_showthread($maybe_threadleader)))))));
		    pxml_xhtml_print_fast($page, $out, "en");
		    $out->xclose;
		}
	    } $m;
	}, $index->messages_threadsorted;

	if ($opt_json_to) {
	    $json->end;
	    $o->xclose;
	}
    };

    &$allout;
}

use Chj::Backtrace;
if ($opt_repl) {
    import Chj::Ml2json::MIMEExtract ':all';
    require Chj::Ml2json::Debug;
    import Chj::Ml2json::Debug;
    require Chj::repl; Chj::repl::repl();
} else {
    parse_and_convert if @ARGV;
}
