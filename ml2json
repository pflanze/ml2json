#!/usr/bin/perl -w

# Thu Jul  4 21:30:42 BST 2013
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/perllib";
use lib "$mydir/ftemplate/lib";
use lib "$mydir/lib";

our $tmpbase="/tmp/$myname";
our $tmplink= "$ENV{HOME}/.$myname-tmp"; ## ok to use that path?
our $mbox_glob= '*.mbox';

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname sourcedir-or-file targetfile

  sourcedir should be a directory with *.mbox files directly in it
  ($myname does not currently recurse into subdirectories).
  If a file is given instead, it is assumed to be an mbox file.

  targetfile is where the JSON output should go (use '-' for stdout).

  Options:
    --verbose   show NOTEs in addition to WARNings on stderr

    --recurse   recurse into subdirectories of sourcedir-or-file

    --mbox-glob globstring
                glob to use to find files in directories that contain
                mboxes. Defaults to '$mbox_glob'.

    --cleanup   delete currently used temp directory at $tmpbase*

    --attachment-basedir path
                use path instead of a random subdirectory below
                '$tmpbase' for the output; the output currently
                contains serialized objects as well, but those don't
                hurt, do they?
                If path is absolute, then the url field for
                attachments is output as file:// URI, if it is
                relative, it is output as a relative URI (i.e. no
                file:// prefix).

    --config myconfig.pl
                load given file containing perl code, which must
                end with a perl hashref; currently
                   'jsonfields_orig_headers' and 'jsonfields_top'
                are used. See docs in lib/Chj/Ml2json/OutputJSON.pm


    --max-date-deviation seconds
                When mbox separators (lines starting with 'From ')
                contain time stamps, and those deviate more than
                <seconds> from the Date header contained in the mail
                (of if there is no Date header in the mail), use the
                mbox time stamp instead. Default: off.  Note: mbox
                time stamps are not necessarily representing the time
                when an email was received, could also be when they
                were copied around.

    --html-to dir
                create html files in the specified directory
                (currently meant for debugging only)

    --deidentify string
                print message identified by the given string, which is
                output into the JSON by the json_identify method (as
                'identify' field by default) or printed along with
                WARN and ERROR messages.
                Only works if the generated files are still available.
                If --attachment-basedir was given before, it has to
                be specified for --deidentify as well.

    --show-mbox-path md5hexstring[/number]
                show path of original mbox file for a given mbox identifier
                (as they are used in identify strings).

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $config;
our $opt_deidentify;
our $opt_show_mbox_path;
our $opt_attachment_basedir;
our $opt_max_date_deviation;
our $opt_recurse;
our $opt_repl;
our $opt_html_to;
GetOptions("verbose"=> \$verbose,
	   "repl"=> \$opt_repl,
	   "help"=> sub{usage},
	   "cleanup"=> sub { cleanup_tmp(); exit 0; },
	   "attachment-basedir=s"=> \$opt_attachment_basedir,
	   "mbox-glob=s"=> \$mbox_glob,
	   "recurse"=> \$opt_recurse,
	   "config=s"=> sub {
	       my ($_,$path)=@_;
	       $config= require $path
	   },
	   "max-date-deviation=n"=> \$opt_max_date_deviation,
	   "html-to=s"=> \$opt_html_to,
	   "deidentify=s"=> \$opt_deidentify,
	   "show-mbox-path=s"=> \$opt_show_mbox_path,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==2 or $opt_deidentify or $opt_show_mbox_path or $opt_repl;

use Chj::NoteWarn;
NoteWarn_attenuation_level($verbose ? 0 : 1);

use Chj::tempdir;

use Chj::xperlfunc ':all';

our $tmp= do {
    if ($opt_attachment_basedir) {
	xmkdir $opt_attachment_basedir if not -d $opt_attachment_basedir;
	$opt_attachment_basedir
    } else {
	my $create= sub {
	    my $t= tempdir $tmpbase;
	    xsymlink $t, $tmplink;
	    $t
	};
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else, creating a new one instead";
		    xunlink $tmplink;
		    &$create;
		}
	    } else {
		xunlink $tmplink;
		&$create;
	    }
	} else {
	    &$create;
	}
    }
};


sub print_deidentify {
    my ($str)=@_;
    my $m= Chj::Ml2json::Debug::deidentify($str,$tmp);
    print $m->ent->as_string
      or die $!;
}
if ($opt_deidentify) {
    require Chj::Ml2json::Debug;
    print_deidentify $opt_deidentify;
}

if ($opt_show_mbox_path) {
    my ($md5)= $opt_show_mbox_path=~ /\b([a-f0-9]{32})\b/
      or usage "does not contain an md5 hex string: '$opt_show_mbox_path'";
    my $p="$tmp/$md5";
    my $mbox= Chj::Ml2json::Ghostable->load($p);
    if (my $path= $mbox->path) {
	print $path,"\n" or die $!;
    } else {
	die "The object stored at '$p' does not have path field, seems to have been generated before adding this feature; run --cleanup and run the conversion again";
    }
}

sub cleanup_tmp {
    if ($opt_attachment_basedir) {
	my $p= $opt_attachment_basedir;
	system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
    } else {
	# partially COPYPASTE..
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p=~ m|^/| or die "not an absolute target location: '$p'";
		    unlink $tmplink;
		    system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else";
		}
	    } else {
		xunlink $tmplink;
	    }
	}
    }
}

use Chj::Ml2json::MailcollectionParser;
use Chj::Ml2json::Message;
use Chj::FP2::Stream ':all';
use Chj::Ml2json::OutputJSON;
use Chj::Ml2json::OutputJSON::Continuous;
use Chj::Try;
use Chj::xopen ':all';
use Chj::Ml2json::Parse::HTML;

our $collectionparser= Chj::Ml2json::MailcollectionParser->new
  ('Chj::Ml2json::Message',
   $mbox_glob,
   $opt_recurse);

our $htmlmapper= Chj::Ml2json::Parse::HTML->new; ## config file input ?

our $outputjson= Chj::Ml2json::OutputJSON->new
  ($$config{jsonfields_orig_headers},
   $$config{jsonfields_top},
   $htmlmapper);

use Chj::PXML::Serialize 'pxml_xhtml_print_fast';
use Chj::PXHTML ':all';
sub with_wrap_if (&$$){
    my ($fn,$val,$cond)=@_;
    $cond ? do{ local $_= $val; &$fn($val)} : $val
}
use Scalar::Util 'weaken';
use Chj::FP::ArrayUtil ':all';


sub parse_and_convert {
    my ($sourcepath, $targetfile)=@ARGV;

    my $coll= $collectionparser->parse_tree($sourcepath, $tmp, $opt_max_date_deviation);

    my $index= $coll->index;

    my $allout= sub {
	my $o= xopen_write $targetfile;
	binmode $o, ":utf8" or die;
	my $json= Chj::Ml2json::OutputJSON::Continuous->new($o,$outputjson);
	stream_for_each sub {
	    my ($m)=@_;
	    Try {
		$json->message_print($m,$index);
		if ($opt_html_to) {
		    my $id= $m->id;
		    my $idn= $m->identify;
		    my $p= $idn;
		    $p=~ s|/|-|g;
		    my $path= "$opt_html_to/$p.xhtml";
		    # iceweasel ignores encoding in .html files, thus
		    # needs to be .xhtml suffix
		    my $out= xopen_write $path;
		    binmode $out, ":utf8" or die;
		    my $fragment= $outputjson->html($m);
		    my $orig_headers= $outputjson->json_orig_headers ($m,$index);
		    my $ctime_UTC= $outputjson->json_ctime_UTC($m,$index);
		    my $inreplyto= $outputjson->json_in_reply_to ($m,$index);
		    my $replies= $outputjson->json_replies($m,$index);
		    my $threadleaders= $outputjson->json_threadleaders($m,$index);
		    my $maybe_threadleader=
		      (@$threadleaders == 1) ? $$threadleaders[0] : undef;
		    my $id2maybe_mg= sub {
			my ($id)=@_;
			if (my $v= $index->ids->{$id}) {
			    $$v[1]
			} else {
			    ()
			}
		    };
		    my $msg_id2maybe_url= sub {
			my ($id)=@_;
			if (my $mg= &$id2maybe_mg ($id)) {
			    my $m= $mg->resurrect; # necessary as $mg->identify is different
			    my $idn= $m->identify;
			    #COPYPASTE from above
			    my $p= $idn;
			    $p=~ s|/|-|g;
			    "$p.xhtml"
			} else {
			    undef
			}
		    };
		    my @choice= $m->origplain_origrich_orightml_string;
		    my $choice= array_zip2 \@choice, [qw(plain rich html)];
		    my $choosen= $outputjson->html_choice($m);
		    #use Chj::repl;repl;


		    ###my $_id2subthread= {}; # for sharing across multiple entry points through threadleaders
		    #wohlsck

# 		    my $threadleader_simplifiedsubject= do {
# 			my $mg= &$id2maybe_mg ($_id);
# 			my $m= $mg->resurrect;
# 			my $orig_headers= $outputjson->json_orig_headers ($m,$index);
# 			subject_simplify($$orig_headers{Subject})
# 		    };

		    my $showthread; $showthread= sub {
			my ($_id)=@_;
			if (my $mg= &$id2maybe_mg ($_id)) {
			    my $m= $mg->resurrect;
			    #hm again COPYPASTE; even again to avoid fetching $m again
			    my $idn= $m->identify;
			    my $p= $idn;
			    $p=~ s|/|-|g;
			    my $url= "$p.xhtml";
			    #/CP
			    my $replies= $outputjson->json_replies($m,$index);
			    my $orig_headers= $outputjson->json_orig_headers ($m,$index);
			    #my $subject= $$orig_headers{Subject};
			    #my $subject_is_same=
			    #  subject_simplify($subject) eq $threadleader_simplifiedsubject;
			    # need to  keep seen ones  too   or only. (if threadleader then show!)
			    #my $cnt= $subject_is_same ? 

			    my $cnt= "$$orig_headers{Subject}, $$orig_headers{From}";
			    my $possiblylinkedcnt=
			      $_id eq $id ? $cnt : A({href=> $url}, $cnt);

			    DIR(
				LI($possiblylinkedcnt),
				map {
				    &$showthread ($_)
				} @$replies
			       )
			} else {
			    # the unknown id's  hm,
			    WARN "shouldn't happen here?: id '$_id'";
			    undef
			}
		    };
		    my $_showthread= $showthread; weaken $showthread;

		    my $page=
		      HTML
			(HEAD (TITLE ($idn)),
			 BODY
			 ({bgcolor=>"#964a2a"},
			  TABLE ({border=>0,
				  cellspacing=>3,
				  cellpadding=>16,
				  width=>"88%",
				  align=>"center",
				 },
				 TR
				 (TD
				  ({bgcolor=> "#f0f8ff"},
				   TABLE
				   ({border=>0},
				    (
				     map {
					 my ($key,$val)=@$_;
					 TR ({valign=>"top"},
					     TD ({align=>"right"},
						 "$key:$nbsp"),
					     TD ($val))
				     }
				     ["Subject",
				      #with_wrap_if {
				      #	  A({href=> &$msg_id2url ($maybe_threadleader)}, $_)
				      #} B($$orig_headers{Subject}), $maybe_threadleader
				      #sigh, more complicated (maybe monad?):
				      do {
					  my $V0= B($$orig_headers{Subject});
					  if ($maybe_threadleader
					      and $maybe_threadleader ne $id) {
					      if (my $V2= &$msg_id2maybe_url ($maybe_threadleader)) {
						  A({href=> $V2}, $V0)
					      } else {
						  $V0
					      }
					  } else {
					      $V0
					  }
				      }
				     ],
				     ["From", $$orig_headers{From}],
				     ["To", $$orig_headers{To},
				      ($$orig_headers{Cc} and ", Cc: $$orig_headers{Cc}")],
				     ["Date",
				      [$$orig_headers{Date}, $nbsp, " (", $ctime_UTC, " UTC)"]]
				     ),
				    TR(TD(SMALL("Message-ID:")),
				       TD(SMALL($id," ",$nbsp," ",
						"  $nbsp Available:",
						map {
						    my ($used,$msg)=@$_;
						    ($used
						     ? [" ",
							($choosen eq $msg ? B($msg) : $msg)]
						     : undef)
						} @$choice)))))),
				 TR (TD ({bgcolor=> "#e0f0ff"}, $fragment)),
				 TR (TD ({bgcolor=> "#f0f8ff"},
					 ($maybe_threadleader and
					  &$_showthread($maybe_threadleader)))))));
		    pxml_xhtml_print_fast($page, $out, "en");
		    $out->xclose;
		}
	    } $m;
	}, $index->messages_threadsorted;
	$json->end;
	$o->xclose;
    };

    &$allout;
}

use Chj::Backtrace;
if ($opt_repl) {
    import Chj::Ml2json::MIMEExtract ':all';
    require Chj::Ml2json::Debug;
    import Chj::Ml2json::Debug;
    require Chj::repl; Chj::repl::repl();
} else {
    parse_and_convert if @ARGV;
}
