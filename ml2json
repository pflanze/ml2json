#!/usr/bin/perl -w

# Thu Jul  4 21:30:42 BST 2013
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/perllib";
use lib "$mydir/ftemplate/lib";
use lib "$mydir/lib";

our $tmpbase="/tmp/$myname";
our $tmplink= "$ENV{HOME}/.$myname-tmp"; ## ok to use that path?

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname sourcedir targetfile

  sourcedir should be a directory with *.mbox files directly in it
  ($myname does not currently recurse into subdirectories).

  targetfile is where the JSON output should go (use '-' for stdout).

  Options:

    --cleanup   delete currently used temp directory at $tmpbase*

    --attachment-basedir path
                use path instead of a random subdirectory below
                '$tmpbase' for the output; the output currently
                contains serialized objects as well, but those don't
                hurt, do they?
                If path is absolute, then the url field for
                attachments is output as file:// URI, if it is
                relative, it is output as a relative URI (i.e. no
                file:// prefix).

    --config myconfig.pl
                load given file containing perl code, which must
                end with a perl hashref; currently
                   'jsonfields_orig_headers' and 'jsonfields_top'
                are used. See docs in lib/Chj/Ml2json/OutputJSON.pm

    --deidentify string
                print message identified by the given string, which is
                output into the JSON by the json_identify method (as
                'identify' field by default) or printed along with
                WARN and ERROR messages.
                Only works if the generated files are still available.
                If --attachment-basedir was given before, it has to
                be specified for --deidentify as well.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $tmp;
our $config;
our $opt_deidentify;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "cleanup"=> sub { cleanup_tmp(); exit 0; },
	   "attachment-basedir=s"=> \$tmp,
	   "config=s"=> sub {
	       my ($_,$path)=@_;
	       $config= require $path
	   },
	   "deidentify=s"=> \$opt_deidentify,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==2 or $opt_deidentify;

use Chj::tempdir;

use Chj::xperlfunc ':all';

$tmp ||= do {
    my $create= sub {
	my $t= tempdir $tmpbase;
	xsymlink $t, $tmplink;
	$t
    };
    if (my $p= readlink( $tmplink)) {
	if (my $s= Xstat $p) {
	    if ($s->uid == $>) {
		$p
	    } else {
		warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else, creating a new one instead";
		xunlink $tmplink;
		&$create;
	    }
	} else {
	    xunlink $tmplink;
	    &$create;
	}
    } else {
	&$create;
    }
};


sub print_deidentify {
    my ($str)=@_;
    my $m= Chj::Ml2json::Debug::deidentify($str,$tmp);
    print $m->ent->as_string
      or die $!;
}
if ($opt_deidentify) {
    require Chj::Ml2json::Debug;
    print_deidentify $opt_deidentify;
    exit 0;
}

sub cleanup_tmp {
    # partially COPYPASTE..
    if (my $p= readlink( $tmplink)) {
	if (my $s= Xstat $p) {
	    if ($s->uid == $>) {
		$p=~ m|^/| or die "not an absolute target location: '$p'";
		unlink $tmplink;
		system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
	    } else {
		warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else";
	    }
	} else {
	    xunlink $tmplink;
	}
    }
}

use Chj::Ml2json::Mailcollection ':all';
use Chj::FP2::Stream ':all';
use Chj::Ml2json::OutputJSON;
use Chj::Ml2json::OutputJSON::Continuous;
use Chj::Ml2json::Try;
use Chj::xopen ':all';

our ($sourcedir, $targetfile)=@ARGV;

#our $coll= parse_mbox ('mbox/foucault-l.mbox.crdownload.1', $tmp);
our $coll= parse_mbox_dir ($sourcedir, $tmp);

our $index= $coll->index;

our $outputjson= Chj::Ml2json::OutputJSON->new
  ($$config{jsonfields_orig_headers},
   $$config{jsonfields_top});

sub allout {
    my $o= xopen_write $targetfile;
    binmode $o, ":utf8" or die;
    my $json= Chj::Ml2json::OutputJSON::Continuous->new($o,$outputjson);
    stream_for_each sub {
	my ($m)=@_;
	Try {
	    $json->message_print($m,$index);
	} $m;
    }, $index->messages_threadsorted;
    $json->end;
    $o->xclose;
}

#use Chj::Ml2json::Debug;
#use Chj::Ml2json::MIMEExtract ':all';
use Chj::Backtrace;
#use Chj::repl; repl;
allout;
