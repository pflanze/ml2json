#!/usr/bin/perl -w

# Thu Jul  4 21:30:42 BST 2013
(my $email='ch%christianjaeger,ch')=~ tr/%,/@./;

use strict;

my ($mydir, $myname);
BEGIN {
    $0=~ /(.*?)([^\/]+)\z/s or die "?";
    ($mydir, $myname)=($1,$2);
}
use lib "$mydir/perllib";
use lib "$mydir/ftemplate/lib";
use lib "$mydir/lib";

our $tmpbase="/tmp/$myname";
our $tmplink= "$ENV{HOME}/.$myname-tmp"; ## ok to use that path?
our $mbox_glob= '*.mbox';

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname sourcedir-or-file targetfile

  sourcedir should be a directory with *.mbox files directly in it
  ($myname does not currently recurse into subdirectories).
  If a file is given instead, it is assumed to be an mbox file.

  targetfile is where the JSON output should go (use '-' for stdout).

  Options:
    --verbose   show NOTEs in addition to WARNings on stderr

    --recurse   recurse into subdirectories of sourcedir-or-file

    --mbox-glob globstring
                glob to use to find files in directories that contain
                mboxes. Defaults to '$mbox_glob'.

    --cleanup   delete currently used temp directory at $tmpbase*

    --attachment-basedir path
                use path instead of a random subdirectory below
                '$tmpbase' for the output; the output currently
                contains serialized objects as well, but those don't
                hurt, do they?
                If path is absolute, then the url field for
                attachments is output as file:// URI, if it is
                relative, it is output as a relative URI (i.e. no
                file:// prefix).

    --config myconfig.pl
                load given file containing perl code, which must
                end with a perl hashref; currently
                   'jsonfields_orig_headers' and 'jsonfields_top'
                are used. See docs in lib/Chj/Ml2json/OutputJSON.pm


    --max-date-deviation seconds
                When mbox separators (lines starting with 'From ')
                contain time stamps, and those deviate more than
                <seconds> from the Date header contained in the mail
                (of if there is no Date header in the mail), use the
                mbox time stamp instead. Default: off.  Note: mbox
                time stamps are not necessarily representing the time
                when an email was received, could also be when they
                were copied around.

    --deidentify string
                print message identified by the given string, which is
                output into the JSON by the json_identify method (as
                'identify' field by default) or printed along with
                WARN and ERROR messages.
                Only works if the generated files are still available.
                If --attachment-basedir was given before, it has to
                be specified for --deidentify as well.

    --show-mbox-path md5hexstring[/number]
                show path of original mbox file for a given mbox identifier
                (as they are used in identify strings).

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our $opt_dry;
our $config;
our $opt_deidentify;
our $opt_show_mbox_path;
our $opt_attachment_basedir;
our $opt_max_date_deviation;
our $opt_recurse;
our $opt_repl;
GetOptions("verbose"=> \$verbose,
	   "repl"=> \$opt_repl,
	   "help"=> sub{usage},
	   "cleanup"=> sub { cleanup_tmp(); exit 0; },
	   "attachment-basedir=s"=> \$opt_attachment_basedir,
	   "mbox-glob=s"=> \$mbox_glob,
	   "recurse"=> \$opt_recurse,
	   "config=s"=> sub {
	       my ($_,$path)=@_;
	       $config= require $path
	   },
	   "max-date-deviation=n"=> \$opt_max_date_deviation,
	   "deidentify=s"=> \$opt_deidentify,
	   "show-mbox-path=s"=> \$opt_show_mbox_path,
	   #"dry-run"=> \$opt_dry,
	   ) or exit 1;
usage unless @ARGV==2 or $opt_deidentify or $opt_show_mbox_path or $opt_repl;

use Chj::NoteWarn;
NoteWarn_attenuation_level($verbose ? 0 : 1);

use Chj::tempdir;

use Chj::xperlfunc ':all';

our $tmp= do {
    if ($opt_attachment_basedir) {
	xmkdir $opt_attachment_basedir if not -d $opt_attachment_basedir;
	$opt_attachment_basedir
    } else {
	my $create= sub {
	    my $t= tempdir $tmpbase;
	    xsymlink $t, $tmplink;
	    $t
	};
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else, creating a new one instead";
		    xunlink $tmplink;
		    &$create;
		}
	    } else {
		xunlink $tmplink;
		&$create;
	    }
	} else {
	    &$create;
	}
    }
};


sub print_deidentify {
    my ($str)=@_;
    my $m= Chj::Ml2json::Debug::deidentify($str,$tmp);
    print $m->ent->as_string
      or die $!;
}
if ($opt_deidentify) {
    require Chj::Ml2json::Debug;
    print_deidentify $opt_deidentify;
}

if ($opt_show_mbox_path) {
    my ($md5)= $opt_show_mbox_path=~ /\b([a-f0-9]{32})\b/
      or usage "does not contain an md5 hex string: '$opt_show_mbox_path'";
    my $p="$tmp/$md5";
    my $mbox= Chj::Ml2json::Ghostable->load($p);
    if (my $path= $mbox->path) {
	print $path,"\n" or die $!;
    } else {
	die "The object stored at '$p' does not have path field, seems to have been generated before adding this feature; run --cleanup and run the conversion again";
    }
}

sub cleanup_tmp {
    if ($opt_attachment_basedir) {
	my $p= $opt_attachment_basedir;
	system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
    } else {
	# partially COPYPASTE..
	if (my $p= readlink( $tmplink)) {
	    if (my $s= Xstat $p) {
		if ($s->uid == $>) {
		    $p=~ m|^/| or die "not an absolute target location: '$p'";
		    unlink $tmplink;
		    system ("rm", "-rf", "--", $p)==0 or die "rm -rf '$p' failed";
		} else {
		    warn "directory pointed to by '$tmplink' ('$p') is owned by somebody else";
		}
	    } else {
		xunlink $tmplink;
	    }
	}
    }
}

use Chj::Ml2json::MailcollectionParser;
use Chj::Ml2json::Message;
use Chj::FP2::Stream ':all';
use Chj::Ml2json::OutputJSON;
use Chj::Ml2json::OutputJSON::Continuous;
use Chj::Try;
use Chj::xopen ':all';
use Chj::Ml2json::Parse::HTML;

our $collectionparser= Chj::Ml2json::MailcollectionParser->new
  ('Chj::Ml2json::Message',
   $mbox_glob,
   $opt_recurse);

our $htmlmapper= Chj::Ml2json::Parse::HTML->new; ## config file input ?

our $outputjson= Chj::Ml2json::OutputJSON->new
  ($$config{jsonfields_orig_headers},
   $$config{jsonfields_top},
   $htmlmapper);

sub parse_and_convert {
    my ($sourcepath, $targetfile)=@ARGV;

    my $coll= $collectionparser->parse_tree($sourcepath, $tmp, $opt_max_date_deviation);

    my $index= $coll->index;

    my $allout= sub {
	my $o= xopen_write $targetfile;
	binmode $o, ":utf8" or die;
	my $json= Chj::Ml2json::OutputJSON::Continuous->new($o,$outputjson);
	stream_for_each sub {
	    my ($m)=@_;
	    Try {
		$json->message_print($m,$index);
	    } $m;
	}, $index->messages_threadsorted;
	$json->end;
	$o->xclose;
    };

    &$allout;
}

use Chj::Backtrace;
if ($opt_repl) {
    import Chj::Ml2json::MIMEExtract ':all';
    require Chj::Ml2json::Debug;
    import Chj::Ml2json::Debug;
    require Chj::repl; Chj::repl::repl();
} else {
    parse_and_convert if @ARGV;
}
